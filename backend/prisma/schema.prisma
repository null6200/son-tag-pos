model AppRole {
  id          String   @id @default(uuid())
  branch      Branch   @relation(fields: [branchId], references: [id])
  branchId    String
  name        String
  permissions String[]
  archived    Boolean  @default(false)

  users User[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([branchId, name])
}

// Subcategories (product sub-categories)
model Subcategory {
  id       String  @id @default(uuid())
  name     String
  code     String?
  branch   Branch? @relation(fields: [branchId], references: [id])
  branchId String?

  createdAt DateTime @default(now())

  @@index([branchId])
}

// Cross-device POS drafts (saved carts)
model Draft {
  id            String   @id @default(uuid())
  branch        Branch   @relation(fields: [branchId], references: [id])
  branchId      String
  section       Section? @relation(fields: [sectionId], references: [id])
  sectionId     String?
  table         Table?   @relation(fields: [tableId], references: [id])
  tableId       String?
  order         Order?   @relation(fields: [orderId], references: [id])
  orderId       String?
  name          String
  serviceType   String
  waiterId      String?
  customerName  String?
  customerPhone String?
  cart          Json
  subtotal      Decimal  @db.Decimal(12, 2)
  discount      Decimal  @db.Decimal(12, 2)
  tax           Decimal  @db.Decimal(12, 2)
  total         Decimal  @db.Decimal(12, 2)
  status        String   // ACTIVE | SUSPENDED
  reservationKey String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([branchId])
  @@index([sectionId])
  @@index([tableId])
  @@index([orderId])
}

// Customers/Contacts maintained by admin, scoped to branch
model Customer {
  id        String  @id @default(uuid())
  branch    Branch  @relation(fields: [branchId], references: [id])
  branchId  String

  name      String
  phone     String?
  email     String?
  notes     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([branchId])
}

// Configurable Service Types (e.g., Dine-in, Takeaway) per branch
model ServiceType {
  id          String  @id @default(uuid())
  name        String
  description String?
  branch      Branch  @relation(fields: [branchId], references: [id])
  branchId    String
  archived    Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([branchId, name])
}

// HRM
enum EmploymentStatus {
  ACTIVE
  INACTIVE
}

enum AttendanceSource {
  POS
  MANUAL
}

enum LeaveType {
  ANNUAL
  SICK
  UNPAID
  OTHER
}

enum LeaveStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

model EmployeeProfile {
  id              String           @id @default(uuid())
  user            User             @relation(fields: [userId], references: [id])
  userId          String           @unique
  branch          Branch           @relation(fields: [branchId], references: [id])
  branchId        String
  status          EmploymentStatus @default(ACTIVE)
  jobTitle        String?
  hireDate        DateTime         @default(now())
  terminationDate DateTime?
  hourlyRate      Decimal?         @db.Decimal(12, 2)
  pinHash         String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Refresh tokens for rotating-session auth
model RefreshToken {
  id         String   @id @default(uuid())
  user       User     @relation(fields: [userId], references: [id])
  userId     String
  tokenHash  String   // hash of the refresh token
  userAgent  String?
  ipAddress  String?
  expiresAt  DateTime
  lastUsedAt DateTime @default(now())
  revoked    Boolean  @default(false)

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([userId])
  @@index([expiresAt])
}

model ShiftAssignment {
  id       String   @id @default(uuid())
  user     User     @relation(fields: [userId], references: [id])
  userId   String
  branch   Branch   @relation(fields: [branchId], references: [id])
  branchId String
  startAt  DateTime
  endAt    DateTime
  notes    String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, startAt])
}

model Attendance {
  id       String           @id @default(uuid())
  user     User             @relation(fields: [userId], references: [id])
  userId   String
  branch   Branch           @relation(fields: [branchId], references: [id])
  branchId String
  clockIn  DateTime
  clockOut DateTime?
  source   AttendanceSource @default(POS)
  notes    String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, clockIn])
}

model LeaveRequest {
  id           String      @id @default(uuid())
  user         User        @relation(fields: [userId], references: [id])
  userId       String
  branch       Branch      @relation(fields: [branchId], references: [id])
  branchId     String
  type         LeaveType
  startDate    DateTime
  endDate      DateTime
  status       LeaveStatus @default(PENDING)
  reason       String?
  approvedBy   User?       @relation("LeaveApprovedBy", fields: [approvedById], references: [id])
  approvedById String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([branchId, status])
}

// Prisma schema for POS/ERP backend (PostgreSQL)
// Run after network is available:
// npx prisma migrate dev --name init
// npx prisma generate

generator client {
  provider = "prisma-client-js"
  // Include native for local dev, linux-musl for Alpine, and debian for Debian-based images
  binaryTargets = ["native", "linux-musl-openssl-3.0.x", "debian-openssl-3.0.x"]
}

model StockMovement {
  id          String   @id @default(uuid())
  productId   String
  branchId    String
  sectionFrom String? // nullable for branch-level or adds
  sectionTo   String? // nullable for branch-level or removes
  delta       Int // positive for adds to 'to', negative for removes from 'from'
  reason      String // e.g., 'SALE','REFUND','ADJUST','TRANSFER'
  referenceId String? // orderId or adjustment/transfer id
  createdAt   DateTime @default(now())

  product Product @relation(fields: [productId], references: [id])
  branch  Branch  @relation(fields: [branchId], references: [id])

  @@index([branchId, createdAt])
  @@index([productId, createdAt])
}

// New: Sections and Tables
model Section {
  id                String           @id @default(uuid())
  name              String
  description       String?
  sectionFunction   SectionFunction? @relation(fields: [sectionFunctionId], references: [id])
  sectionFunctionId String?
  // legacy: retained for backward compatibility; will be deprecated
  function          String?
  branch            Branch           @relation(fields: [branchId], references: [id])
  branchId          String

  tables             Table[]
  priceLists         PriceList[]
  sectionInventories SectionInventory[]
  orders             Order[]
  drafts             Draft[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Configurable set of functions a Section can have (branch-scoped)
model SectionFunction {
  id          String  @id @default(uuid())
  name        String
  description String?
  branch      Branch  @relation(fields: [branchId], references: [id])
  branchId    String

  sections         Section[]
  productTypeLinks ProductTypeAllowedFunction[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([branchId, name])
}

// Product types (e.g., Bar Item, Kitchen Item) that drive section filtering (branch-scoped)
model ProductType {
  id          String  @id @default(uuid())
  name        String
  description String?
  branch      Branch  @relation(fields: [branchId], references: [id])
  branchId    String

  // Allowed section functions for this product type
  productTypeLinks ProductTypeAllowedFunction[]
  products         Product[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([branchId, name])
}

// Join table mapping ProductType to allowed SectionFunction(s)
model ProductTypeAllowedFunction {
  productType       ProductType     @relation(fields: [productTypeId], references: [id])
  productTypeId     String
  sectionFunction   SectionFunction @relation(fields: [sectionFunctionId], references: [id])
  sectionFunctionId String

  @@id([productTypeId, sectionFunctionId])
}

model Table {
  id        String  @id @default(uuid())
  name      String
  status    String  @default("available") // available, occupied, locked
  section   Section @relation(fields: [sectionId], references: [id])
  sectionId String
  capacity  Int     @default(2)

  drafts    Draft[]
  orders    Order[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([sectionId, name])
}

// New: Price lists and entries (optional section scoping)
model PriceList {
  id        String   @id @default(uuid())
  name      String
  active    Boolean  @default(true)
  branch    Branch   @relation(fields: [branchId], references: [id])
  branchId  String
  section   Section? @relation(fields: [sectionId], references: [id])
  sectionId String?

  entries PriceEntry[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model PriceEntry {
  id          String    @id @default(uuid())
  priceList   PriceList @relation(fields: [priceListId], references: [id])
  priceListId String
  product     Product   @relation(fields: [productId], references: [id])
  productId   String
  price       Decimal   @db.Decimal(12, 2)

  createdAt DateTime @default(now())

  @@unique([priceListId, productId])
}

// New: Payments linked to orders
model Payment {
  id        String   @id @default(uuid())
  order     Order    @relation(fields: [orderId], references: [id])
  orderId   String
  method    String
  amount    Decimal  @db.Decimal(12, 2)
  reference String?
  meta      Json?
  createdAt DateTime @default(now())
}

// Operating expenses per branch
model Expense {
  id        String   @id @default(uuid())
  branch    Branch   @relation(fields: [branchId], references: [id])
  branchId  String
  amount    Decimal  @db.Decimal(12, 2)
  category  String?
  note      String?
  createdAt DateTime @default(now())
}

// Suppliers for purchases (optional branch scope)
model Supplier {
  id       String  @id @default(uuid())
  name     String
  branch   Branch? @relation(fields: [branchId], references: [id])
  branchId String?

  purchases Purchase[]

  createdAt DateTime @default(now())
}

// Brands (optional branch scope)
model Brand {
  id       String  @id @default(uuid())
  name     String
  branch   Branch? @relation(fields: [branchId], references: [id])
  branchId String?

  createdAt DateTime @default(now())

  @@index([branchId])
}

// Categories (branch-scoped)
model Category {
  id       String  @id @default(uuid())
  name     String
  code     String?
  branch   Branch  @relation(fields: [branchId], references: [id])
  branchId String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([branchId, name])
  @@index([branchId])
}

// Purchases
model Purchase {
  id         String    @id @default(uuid())
  branch     Branch    @relation(fields: [branchId], references: [id])
  branchId   String
  supplier   Supplier? @relation(fields: [supplierId], references: [id])
  supplierId String?

  total Decimal @db.Decimal(12, 2)

  items    PurchaseItem[]
  payments PurchasePayment[]
  returns  PurchaseReturn[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([branchId])
}

model PurchaseItem {
  id         String   @id @default(uuid())
  purchase   Purchase @relation(fields: [purchaseId], references: [id])
  purchaseId String
  product    Product  @relation(fields: [productId], references: [id])
  productId  String
  qty        Int
  price      Decimal  @db.Decimal(12, 2)
  createdAt  DateTime @default(now())
}

model PurchasePayment {
  id         String   @id @default(uuid())
  purchase   Purchase @relation(fields: [purchaseId], references: [id])
  purchaseId String
  method     String
  amount     Decimal  @db.Decimal(12, 2)
  reference  String?
  createdAt  DateTime @default(now())
}

// Sales return (refunds) against orders
model SalesReturn {
  id        String   @id @default(uuid())
  order     Order    @relation(fields: [orderId], references: [id])
  orderId   String
  amount    Decimal  @db.Decimal(12, 2)
  createdAt DateTime @default(now())
}

// Purchase returns back to supplier
model PurchaseReturn {
  id         String   @id @default(uuid())
  purchase   Purchase @relation(fields: [purchaseId], references: [id])
  purchaseId String
  amount     Decimal  @db.Decimal(12, 2)
  createdAt  DateTime @default(now())
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN
  MANAGER
  CASHIER
}

enum OrderStatus {
  DRAFT
  ACTIVE
  PENDING_PAYMENT
  SUSPENDED
  PAID
  CANCELLED
  VOIDED
  REFUNDED
}

model User {
  id             String   @id @default(uuid())
  username       String   @unique
  email          String   @unique
  passwordHash   String
  role           Role     @default(CASHIER)
  firstName      String?
  surname        String?
  phone          String?
  isServiceStaff Boolean  @default(false)
  archived       Boolean  @default(false)
  appRole        AppRole? @relation(fields: [appRoleId], references: [id])
  appRoleId      String?
  // Per-user preferences and lightweight runtime flags
  preferences    Json?
  runtime        Json?

  branch   Branch? @relation(fields: [branchId], references: [id])
  branchId String?

  orders           Order[]
  // HRM back-relations
  employeeProfile  EmployeeProfile?
  shiftAssignments ShiftAssignment[]
  attendances      Attendance[]
  leaveRequests    LeaveRequest[]
  approvedLeaves   LeaveRequest[]    @relation("LeaveApprovedBy")

  // Auth sessions
  refreshTokens    RefreshToken[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Branch {
  id       String @id @default(uuid())
  name     String
  location String

  users            User[]
  products         Product[]
  inventory        Inventory[]
  orders           Order[]
  sections         Section[]
  priceLists       PriceList[]
  expenses         Expense[]
  suppliers        Supplier[]
  purchases        Purchase[]
  customers        Customer[]
  // Optional relations
  brands           Brand[]
  categories       Category[]
  subcategories    Subcategory[]
  settings         Setting[]
  nextOrderSeq     Int               @default(0)
  nextSkuSeq       Int               @default(0)
  appRoles         AppRole[]
  // Back-relations for config entities
  sectionFunctions SectionFunction[]
  productTypes     ProductType[]
  serviceTypes     ServiceType[]
  drafts           Draft[]

  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  movements        StockMovement[]
  // HRM
  employeeProfiles EmployeeProfile[]
  shiftAssignments ShiftAssignment[]
  attendances      Attendance[]
  leaveRequests    LeaveRequest[]

  // Security: branch-level override PIN for sensitive actions
  overridePinHash         String?
  overridePinGraceSeconds Int     @default(5)

  @@index([name])
}

model Product {
  id          String   @id @default(uuid())
  name        String
  sku         String
  imageUrl    String?
  category    String?
  subCategory String?
  price       Decimal  @db.Decimal(12, 2)
  taxRate     Decimal? @db.Decimal(5, 2)
  archived    Boolean  @default(false)

  branch   Branch @relation(fields: [branchId], references: [id])
  branchId String

  // Optional type classification to support filtering sections in product creation
  productType   ProductType? @relation(fields: [productTypeId], references: [id])
  productTypeId String?

  inventory          Inventory[]
  sectionInventories SectionInventory[]
  orderItems         OrderItem[]
  priceEntries       PriceEntry[]
  purchaseItems      PurchaseItem[]
  movements          StockMovement[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name])
  @@index([branchId])
  @@unique([branchId, sku])
}

model Inventory {
  id        String  @id @default(uuid())
  product   Product @relation(fields: [productId], references: [id])
  productId String
  branch    Branch  @relation(fields: [branchId], references: [id])
  branchId  String
  qtyOnHand Int     @default(0)
  minLevel  Int     @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([productId, branchId])
}

// New: Per-section inventory
model SectionInventory {
  id        String  @id @default(uuid())
  product   Product @relation(fields: [productId], references: [id])
  productId String
  section   Section @relation(fields: [sectionId], references: [id])
  sectionId String
  qtyOnHand Int     @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([productId, sectionId])
}

model Order {
  id        String   @id @default(uuid())
  branch    Branch   @relation(fields: [branchId], references: [id])
  branchId  String
  section   Section? @relation(fields: [sectionId], references: [id])
  sectionId String?
  user      User?    @relation(fields: [userId], references: [id])
  userId    String?
  // Optional service staff (waiter) handling this order
  waiterId    String?
  waiterName  String?
  table     Table?   @relation(fields: [tableId], references: [id])
  tableId   String?

  status      OrderStatus @default(PAID)
  total       Decimal     @db.Decimal(12, 2)
  orderNumber Int
  // Persisted financial breakdown
  subtotal    Decimal     @db.Decimal(12, 2) @default(0)
  discount    Decimal     @db.Decimal(12, 2) @default(0)
  tax         Decimal     @db.Decimal(12, 2) @default(0)
  taxRate     Decimal?    @db.Decimal(5, 2)
  // Service type: Dine-in, Takeaway, etc.
  serviceType String?

  items        OrderItem[]
  payments     Payment[]
  salesReturns SalesReturn[]
  drafts       Draft[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([branchId, orderNumber])
  @@index([branchId])
  @@index([sectionId])
  @@index([userId])
  @@index([createdAt])
  @@index([tableId])
}

model OrderItem {
  id        String  @id @default(uuid())
  order     Order   @relation(fields: [orderId], references: [id])
  orderId   String
  product   Product @relation(fields: [productId], references: [id])
  productId String
  qty       Int
  price     Decimal @db.Decimal(12, 2)

  createdAt DateTime @default(now())

  @@index([orderId])
  @@index([productId])
}

// Shift register persistence
model Shift {
  id           String    @id @default(uuid())
  branchId     String
  sectionId    String?
  openedById   String
  closedById   String?
  openedAt     DateTime  @default(now())
  closedAt     DateTime?
  openingCash  Decimal   @db.Decimal(12, 2)
  closingCash  Decimal?  @db.Decimal(12, 2)
  expectedCash Decimal   @db.Decimal(12, 2)
  difference   Decimal?  @db.Decimal(12, 2)
  status       String    @default("OPEN") // OPEN, CLOSED
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([branchId])
  @@index([openedAt])
}

// Optional: Simple audit log for overrides and critical actions
model AuditLog {
  id        String   @id @default(uuid())
  action    String
  userId    String?
  branchId  String?
  meta      Json?
  createdAt DateTime @default(now())

  @@index([branchId, createdAt])
}

// Application settings, optionally per-branch
model Setting {
  id           String   @id @default(uuid())
  branch       Branch?  @relation(fields: [branchId], references: [id])
  branchId     String?
  businessName String?
  currency     String?
  // Branding/contact fields used by the frontend
  logoUrl      String?
  address      String?
  phone        String?
  email        String?
  currencySymbol String?
  theme        String?
  taxRate      Decimal? @db.Decimal(5, 2)
  allowOverselling Boolean @default(false)
  // Custom print footer notes
  receiptFooterNote String?
  invoiceFooterNote String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([branchId])
}
